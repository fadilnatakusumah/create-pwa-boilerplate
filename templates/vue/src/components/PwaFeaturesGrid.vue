<script setup lang="ts">
import { ref, computed, watch, onUnmounted, nextTick } from "vue";

// --- Global Type Definitions for Safety ---
// Extend Window interface for Battery Status API
declare global {
  interface Navigator {
    getBattery?: () => Promise<BatteryManager>;
  }
}
interface BatteryManager extends EventTarget {
  charging: boolean;
  chargingTime: number;
  dischargingTime: number;
  level: number;
  onchargingchange: ((this: BatteryManager, ev: Event) => any) | null;
  onlevelchange: ((this: BatteryManager, ev: Event) => any) | null;
}

const log = ref<string[]>([]);
const cameraActive = ref(false);
const videoRef = ref<HTMLVideoElement | null>(null);
const mediaStream = ref<MediaStream | null>(null); // To hold the active media stream

const appendLog = (msg: string) => {
  log.value = [...log.value.slice(-4), msg]; // Keep log short
};

// --- Push Notification Setup (Constants and Utility) ---
// Use a real, generated VAPID Public Key for testing purposes.
// NOTE: This key must be replaced with one generated by your production server.
const VAPID_PUBLIC_KEY = "YOUR_VAPID_PUBLIC_KEY_HERE"; // Replace with an actual key

const urlBase64ToUint8Array = (base64String: string) => {
  const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding)
    .replace(/\-/g, "+")
    .replace(/_/g, "/");

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
};

// --- Feature Implementation Logic ---

// 1. Camera API Demo (Media Capture)
const handleCamera = async () => {
  if (mediaStream.value) {
    mediaStream.value.getTracks().forEach((track) => track.stop());
    mediaStream.value = null;
    cameraActive.value = false;
    return appendLog("Camera: Stream stopped.");
  }

  try {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      return appendLog("Camera: Not Supported.");
    }
    appendLog("Camera: Requesting access...");

    // 1. Acquire the stream
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });

    // 2. Set BOTH states simultaneously to trigger the v-if and the watch
    mediaStream.value = stream;
    cameraActive.value = true;

    appendLog("Camera: Access granted. Waiting for DOM render...");
  } catch (err) {
    cameraActive.value = false;
    mediaStream.value = null;
    appendLog(
      `Camera: Access denied or failed. Error: ${(err as Error).message}`
    );
  }
};

watch(mediaStream, async (newStream) => {
  if (newStream) {
    // 1. Wait for the DOM update cycle to complete.
    // This ensures v-if="cameraActive" (which relies on mediaStream)
    // has rendered the <video ref="videoRef"> element.
    await nextTick();

    if (videoRef.value) {
      // 2. Assign and Play
      videoRef.value.srcObject = newStream;
      videoRef.value
        .play()
        .catch((e) => console.error("Video play failed:", e));
      appendLog("Camera: Stream successfully connected and playing.");
    } else {
      // This should ideally not be hit, but is a good check.
      appendLog("Camera: Error connecting stream (videoRef not available).");
    }
  }
});

// Clean up stream on unmount
onUnmounted(() => {
  if (mediaStream.value) {
    mediaStream.value.getTracks().forEach((track) => track.stop());
  }
});

// 2. Web Share API Demo
const handleWebShare = async () => {
  if (!navigator.share) {
    return appendLog("Web Share: Not Supported.");
  }

  try {
    await navigator.share({
      title: "PWA Share Demo",
      text: "Check out this awesome PWA Boilerplate!",
      url: window.location.href,
    });
    appendLog("Web Share: Successfully shared content.");
  } catch (err) {
    appendLog(
      `Web Share: Failed or user cancelled. Error: ${(err as Error).message}`
    );
  }
};

// 3. Battery Status API Demo
const handleBatteryStatus = async () => {
  if (!navigator.getBattery) {
    return appendLog("Battery Status: Not Supported.");
  }

  try {
    const battery: BatteryManager = await navigator.getBattery();
    const chargingStatus = battery.charging ? "Charging" : "Discharging";
    const level = Math.round(battery.level * 100);

    appendLog(`Battery Status: ${level}% and ${chargingStatus}.`);
  } catch (err) {
    appendLog(
      `Battery Status: Failed to read status. Error: ${(err as Error).message}`
    );
  }
};

// 4. Vibration API Demo
const handleVibrate = () => {
  if (!("vibrate" in navigator)) {
    return appendLog("Vibration: Not Supported.");
  }
  navigator.vibrate([200, 100, 200]);
  appendLog("Vibration: Success! Check your mobile device.");
};

// 5. Geolocation API Demo
const handleGeolocation = () => {
  if (!("geolocation" in navigator)) {
    return appendLog("Geolocation: Not Supported.");
  }
  appendLog("Geolocation: Requesting position...");
  navigator.geolocation.getCurrentPosition(
    (position: GeolocationPosition) => {
      appendLog(
        `Geolocation: Lat: ${position.coords.latitude}, Lon: ${position.coords.longitude}`
      );
    },
    (error: GeolocationPositionError) => {
      appendLog(`Geolocation error: ${error.message}`);
    }
  );
};

// 6. Push Notifications
const handlePushSubscription = async () => {
  if (!("Notification" in window) || !("PushManager" in window)) {
    return appendLog("Push Notifications: Not Supported.");
  }

  try {
    const permission = await Notification.requestPermission();
    if (permission !== "granted") {
      return appendLog(`Push Notifications: Permission denied or dismissed.`);
    }
    appendLog("Push Notifications: Permission granted.");

    const registration = await navigator.serviceWorker.ready;

    const applicationServerKey = urlBase64ToUint8Array(VAPID_PUBLIC_KEY);

    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: applicationServerKey,
    });

    appendLog("Push Notifications: Successfully subscribed user.");
    // --- Simulate sending subscription to a backend ---
    console.log("Simulating sending subscription to backend:", subscription);
    // In a real app, you would send this 'subscription' object to your server via fetch()
    /*
        const response = await fetch('/api/subscribe', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(subscription),
        });
        if (response.ok) {
            appendLog('Push Notifications: Successfully subscribed and saved to server.');
        } else {
            const errorText = await response.text();
            appendLog(`Push Notifications: Server failed to save subscription. Status: ${response.status}. Detail: ${errorText.substring(0, 50)}...`);
        }
        */
  } catch (err) {
    appendLog(
      `Push Notifications: Subscription failed. Error: ${
        (err as Error).message
      }`
    );
  }
};

// --- Grid Data Setup ---
interface FeatureStatus {
  name: string;
  icon: string;
  action: () => void;
  isSupported: boolean;
  message: string;
}

const features = computed<FeatureStatus[]>(() => [
  {
    name: `Camera (${cameraActive.value ? "ON" : "OFF"})`,
    icon: cameraActive.value ? "üî¥" : "üì∑",
    action: handleCamera,
    isSupported: !!(
      navigator.mediaDevices && navigator.mediaDevices.getUserMedia
    ),
    message: "Toggle camera access and stream.",
  },
  {
    name: "Web Share",
    icon: "üì§",
    action: handleWebShare,
    isSupported: !!navigator.share,
    message: "Share content with native system dialogue.",
  },
  {
    name: "Battery Status",
    icon: "üîã",
    action: handleBatteryStatus,
    isSupported: !!navigator.getBattery,
    message: "Get current charge level and status.",
  },
  {
    name: "Push Notifications",
    icon: "üîî",
    action: handlePushSubscription,
    isSupported: "Notification" in window && "PushManager" in window,
    message: "Request permission and register for push messages.",
  },
  {
    name: "Geolocation",
    icon: "üìç",
    action: handleGeolocation,
    isSupported: "geolocation" in navigator,
    message: "Get your current geographical location.",
  },
  {
    name: "Vibration",
    icon: "üì≥",
    action: handleVibrate,
    isSupported: "vibrate" in navigator,
    message: "Vibrate the device (mobile only).",
  },
]);
</script>

<template>
  <div :class="$style.grid">
    <h1 :class="$style.header">PWA Capabilities Dashboard</h1>

    <div v-if="cameraActive" :class="$style.cameraContainer">
      <video
        ref="videoRef"
        autoPlay
        playsInline
        muted
        :class="$style.video"
      ></video>
    </div>

    <div :class="$style.cardList">
      <div
        v-for="(feature, index) in features"
        :key="index"
        @click="feature.isSupported ? feature.action() : undefined"
        :class="[
          // üîë Apply the base class
          $style.featureCard,
          // üîë Apply the modifier/state class conditionally
          !feature.isSupported && $style.unsupported,
        ]"
      >
        <div :class="$style.featureIcon">
          {{ feature.icon }}
        </div>
        <div :class="$style.featureName">
          {{ feature.name }}
        </div>
        <p :class="$style.featureMessage">
          {{ feature.message }}
        </p>
      </div>
    </div>

    <h2 :class="$style.logHeader">Event Log</h2>
    <div :class="$style.logContainer">
      <div v-for="(msg, i) in log" :key="i">{{ i + 1 }}. {{ msg }}</div>
      <div v-if="log.length === 0">
        Click a feature card to see the results...
      </div>
    </div>
  </div>
</template>

<style lang="css" module>
/* --- Layout and Structure --- */

.grid {
  padding: 2rem;
  max-width: 80rem; /* 7xl */
  margin-left: auto;
  margin-right: auto;
}

.header {
  font-size: 1.875rem; /* 3xl */
  font-weight: 700;
  margin-bottom: 2rem;
}

.cardList {
  display: grid;
  grid-template-columns: repeat(1, minmax(0, 1fr));
  gap: 1.5rem; /* gap-6 */
}

@media (min-width: 640px) {
  .cardList {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}

@media (min-width: 1024px) {
  .cardList {
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }
}

/* --- Card Styles --- */

.featureCard {
  padding: 1.5rem;
  border: 1px solid #d1d5db;
  border-radius: 0.75rem; /* rounded-xl */
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
    0 4px 6px -4px rgba(0, 0, 0, 0.05); /* shadow-lg */

  /* bg-green-200 ring-2 ring-indigo-200 (Default supported state) */
  background-color: #d1fae5;
  box-shadow: 0 0 0 2px #c7d2fe, 0 10px 15px -3px rgba(0, 0, 0, 0.1); /* ring-2 */
}

.featureCard:hover {
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
    0 8px 10px -6px rgba(0, 0, 0, 0.1); /* shadow-xl */
  background-color: #a7f3d0;
}

.unsupported {
  background-color: #f3f4f6;
  opacity: 0.6;
  pointer-events: none;
  cursor: default;
  box-shadow: none; /* Remove shadow/ring for disabled state */
}

.featureIcon {
  /* text-4xl mb-3 */
  font-size: 2.25rem;
  margin-bottom: 0.75rem;
}

.featureName {
  font-weight: 600;
  color: #4b5563;
}

.featureMessage {
  font-size: 0.875rem;
  color: #4b5563;
  margin-top: 0.25rem;
}

/* --- Camera and Video --- */

.cameraContainer {
  margin-bottom: 2rem;
  border: 4px solid #6366f1;
  border-radius: 0.5rem;
  overflow: hidden;
}

.video {
  width: 100%;
  height: auto;
  aspect-ratio: 16 / 9;
  object-fit: cover;
  display: block;
}

/* --- Log Area --- */

.logHeader {
  font-size: 1.25rem;
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 0.75rem;
}

.logContainer {
  background-color: #1f2937;
  color: #ffffff;
  padding: 1rem;
  height: 10rem; /* h-40 */
  overflow-y: scroll;
  font-size: 0.875rem;
  border-radius: 0.5rem;
  font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier,
    monospace;
}
</style>
